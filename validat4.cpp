// validat2.cpp - written and placed in the public domain by Wei Dai

#include "pch.h"

#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1

#include "cryptlib.h"
#include "pubkey.h"
#include "gfpcrypt.h"
#include "eccrypto.h"
#include "blumshub.h"
#include "filters.h"
#include "files.h"
#include "rsa.h"
#include "md2.h"
#include "elgamal.h"
#include "nr.h"
#include "dsa.h"
#include "dh.h"
#include "mqv.h"
#include "hmqv.h"
#include "fhmqv.h"
#include "luc.h"
#include "xtrcrypt.h"
#include "rabin.h"
#include "rw.h"
#include "eccrypto.h"
#include "integer.h"
#include "gf2n.h"
#include "ecp.h"
#include "ec2n.h"
#include "asn.h"
#include "rng.h"
#include "hex.h"
#include "oids.h"
#include "esign.h"
#include "osrng.h"
#include "smartptr.h"

#include <iostream>
#include <sstream>
#include <iomanip>

#include "validate.h"

// Aggressive stack checking with VS2005 SP1 and above.
#if (CRYPTOPP_MSC_VERSION >= 1410)
# pragma strict_gs_check (on)
#endif

// Quiet deprecated warnings intended to benefit users.
#if CRYPTOPP_MSC_VERSION
# pragma warning(disable: 4996)
#endif

#if CRYPTOPP_GCC_DIAGNOSTIC_AVAILABLE
# pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

USING_NAMESPACE(CryptoPP)

// Test data generated with Crypto++ 5.6.2.
bool ValidateLegacyDLIES()
{
	std::cout << "\nLegacy DLIES validation suite running...\n\n";

	bool pass = true, fail;
	static const char plain[] = "abc";

	{
		// 1024 modulus, SHA1
		static const size_t size = 620;
		static const byte cipher[size+1] =
			"\x06\x50\x83\xF2\x70\xCC\x22\x34\x99\x24\xE2\xCC\xB3\x64\x4F\x91\x24\x7E\x8C\xB2"
			"\xE3\x79\x65\x79\x5B\x64\x62\x12\x56\xF8\x2E\x68\x8D\x50\x5A\xC0\x7D\x87\x5D\x00"
			"\x09\x92\x47\x5C\x31\xBC\x21\xB9\x42\x30\x47\xD6\xF3\xD7\x36\x19\xB7\x02\xE5\x96"
			"\xBE\xF6\x99\x8C\xE1\xAB\xC1\x1D\xE2\x95\x1A\x1D\x72\x62\xEA\x7F\x2E\xF6\xD9\x01"
			"\x63\x81\x05\xA0\xFB\x15\x66\x6F\x2B\xF6\x93\xE7\x24\x1F\x92\x54\x29\x38\x53\xCC"
			"\x25\x39\x01\x80\xF1\xCA\x4A\xF6\x7F\xFA\xCD\xD9\x6A\x62\xC8\x06\xFD\x5D\x38\x74"
			"\x16\x0A\x96\xA3\x32\x91\x60\x80\x79\x01\x8E\x20\xCF\xEB\xA1\x4E\x92\xE5\x6B\xBB"
			"\x58\xA0\xA3\x04\x3E\x0D\xC4\x89\x9F\x89\xB2";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/dlies1024.dat", true, new HexDecoder);
		DLIES<SHA1,NoCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		DLIES<SHA1,NoCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

#if 0
		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "1024-bit, NoCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;
#endif

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// 2048 modulus, SHA1
		static const size_t size = 1144;
		static const byte cipher[size+1] =
			"\x95\x45\xC3\x2D\x46\x5E\x74\xFF\xEE\x98\xAE\x80\xE6\xEB\x5C\x25\x8F\xDE\x55\x29"
			"\x31\xBC\x70\x72\x04\x7D\x99\x6A\xC1\xC1\x5E\x77\xA5\x89\xDE\x9F\x8C\xAC\xDE\x6D"
			"\xBB\xA4\x7D\xA5\xE4\xE4\xEF\x54\x72\xBB\x7D\xF0\xAA\x49\x81\xFF\xE6\xEA\xB3\x1A"
			"\x1A\x68\x19\xDD\x0E\xB9\x49\x99\x46\x18\x9C\xFB\x47\xA2\xDB\xF2\xFD\x01\x37\xBC"
			"\x06\x63\x7E\x04\x39\xFE\x46\x56\x55\xD4\x6B\x5D\xC3\x9D\x69\x86\x8C\xA6\x2C\x83"
			"\xEA\x95\x78\x84\x5F\x25\xA6\x4A\x54\xA0\x14\x43\x32\xC7\x6F\x37\x3B\x7C\x95\x17"
			"\x94\xD9\xAF\x38\x10\xA3\x87\xC9\x6B\x63\xFB\x4B\x82\xB9\x73\x97\xD0\xF1\xC0\x6B"
			"\xFF\xE4\x5E\xB7\x14\xF1\xD6\x07\x00\xB4\xFF\xE9\xD1\x4A\xB0\x5F\x6A\xD1\xA0\xD6"
			"\x9A\x01\x0E\x0F\xD3\x04\x79\x4C\xA9\xEF\xE6\xDB\xB3\xF7\xFE\x72\x41\x32\x96\x3D"
			"\x2E\x9B\x40\xDC\x3D\x44\x29\x38\x84\x3A\x0D\xB6\x03\x05\x08\x0D\x19\xDD\x62\x98"
			"\xBA\x72\xF8\x29\xCE\x87\xD0\x3B\x98\xE9\xD6\x14\xF3\x7F\x23\xC0\x5E\x08\x3E\x78"
			"\xB3\x25\x36\x07\x54\x13\xF9\x3B\x2A\xD0\x1F\x1E\xBC\xA5\xA7\x1A\x2A\x92\xDF\x9E"
			"\xE3\x6B\x0A\x51\xEA\xFF\x89\x2F\x98\x27\x41\x55\xB3\xE5\x1A\x71\xA0\xF1\x52\x5D"
			"\xFA\x3B\x44\xD9\xEA\xDD\xDA\x7D\x58\xF0\x65\xAA\x0A\x98\x9F\xDB\x38\xD5\x8A";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/dlies2048.dat", true, new HexDecoder);
		DLIES<SHA1,NoCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		DLIES<SHA1,NoCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

#if 0
		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "2048-bit, NoCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;
#endif

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// 1024 modulus, SHA1
		static const size_t size = 620;
		static const byte cipher[size+1] =
			"\x17\x48\x21\x11\xC8\x87\xDB\x41\x9A\x75\x6D\x1B\xF4\xCB\x8A\x82\xA2\x65\x87"
			"\x9F\xFA\xCB\x07\x8C\xBE\x22\x08\x90\x71\xA4\xB8\xC1\xD8\x44\x33\x03\xF7\x5F"
			"\xEA\x18\x57\xA9\x95\xD1\x8A\xC5\x29\x8F\xF8\x48\x04\x63\xC7\x43\xDD\x34\x04"
			"\x56\x4C\xD4\xC3\x4A\x98\xC0\x8C\x3E\xC4\x7B\xE3\x6B\xE1\x01\x2D\xBA\xFB\x9E"
			"\x91\xD8\xFC\x54\x69\x75\x79\x0C\xE6\x4D\xF2\x86\xAC\xBF\x14\x04\x95\x51\xBA"
			"\x27\xD3\xEF\x41\x76\x9B\xDF\x74\x71\xC8\x72\x34\xA7\xF2\x79\x6A\x88\x17\x11"
			"\x29\xCF\xD4\xE3\xCC\x00\xAE\x5A\x1A\x11\x22\x9F\x7C\xCA\xD0\x18\xA5\x66\x9A"
			"\x99\x62\x28\xFE\x33\xA5\xC0\x24\xF2\xCE\x06\xF7\xA6\x1C\x97\x28\x13\x6E";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/dlies1024.dat", true, new HexDecoder);
		DLIES<SHA1,CompatibleCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		DLIES<SHA1,CompatibleCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

#if 0
		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "1024-bit, CompatCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;
#endif

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// 2048 modulus, SHA1
		static const size_t size = 1144;
		static const byte cipher[size+1] =
			"\x17\x48\x21\x11\xC8\x87\xDB\x41\x9A\x75\x6D\x1B\xF4\xCB\x8A\x82\xA2\x65\x87"
			"\x9F\xFA\xCB\x07\x8C\xBE\x22\x08\x90\x71\xA4\xB8\xC1\xD8\x44\x33\x03\xF7\x5F"
			"\xEA\x18\x57\xA9\x95\xD1\x8A\xC5\x29\x8F\xF8\x48\x04\x63\xC7\x43\xDD\x34\x04"
			"\x56\x4C\xD4\xC3\x4A\x98\xC0\x8C\x3E\xC4\x7B\xE3\x6B\xE1\x01\x2D\xBA\xFB\x9E"
			"\x91\xD8\xFC\x54\x69\x75\x79\x0C\xE6\x4D\xF2\x86\xAC\xBF\x14\x04\x95\x51\xBA"
			"\x27\xD3\xEF\x41\x76\x9B\xDF\x74\x71\xC8\x72\x34\xA7\xF2\x79\x6A\x88\x17\x11"
			"\x29\xCF\xD4\xE3\xCC\x00\xAE\x5A\x1A\x11\x22\x9F\x7C\xCA\xD0\x18\xA5\x66\x9A"
			"\x99\x62\x28\xFE\x33\xA5\xC0\x24\xF2\xCE\x06\xF7\xA6\x1C\x97\x28\x13\x6E\x77"
			"\xFB\x87\x81\xC8\xC1\xF4\xC4\x1C\x90\x09\x09\x00\x3B\x78\x16\xAA\x38\x21\xD3"
			"\x71\x93\xFB\x5E\x2E\xD6\xC5\x74\x40\xDC\x2E\xE7\x0F\x2A\x2E\x38\x82\xC5\xB1"
			"\x9F\x27\xEC\x93\x34\x98\x67\x3A\x63\x98\xF8\xD0\x56\x75\x34\x52\x1F\x9D\xAA"
			"\x1C\xF7\x3A\x17\x61\xD8\xE4\x94\x1C\x57\xEC\x20\xDF\xA8\x09\xA4\x73\xDD\x8A"
			"\xD5\xBC\x8B\x0A\x22\x18\x32\xB6\x41\xEE\x74\xC9\x27\xB5\xC6\xCA\xB7\x6D\x1E"
			"\x7A\x8F\x04\x61\xFB\x00\x25\xB3\xDC\xDE\xB9\xDA\xA8\xA5\x39\x54\x08\x59\x12"
			"\xD2\x68\xA9\xAC\x90\x12\x2C\x96\xED\x8D\x4A\x7E\xAC\x9E\xF2\xA7\x1B\xCF\x47"
			"\xEE\x85\x2A\x1C\x42\x97\x5E\xF9\x04\xFE\x1B\x2B\x06\x7C\xE0\xC5\x2C\xA7\xD9"
			"\x76\x3B\x00\x7A\xF6\x78\xC1\xE4\x15\x2A\x29\xC4\xB8\x5B\xF6\xD7\x61\xE0\xDF"
			"\xE4\x61\xA8\xA8\xDC\x45\xEE\x2A\x07\x71\x4E\xF3\xBB\xA3\x15\xFC\x28\x0D\xF3"
			"\x1F\x88\x76\xCC\x56\xA9\xBE\xB6\x47\x0C\x94\xA3\x37\x3C\xDB\x22\xD5\x8E\x1A"
			"\x2A\x23\xAE\xCC\x4A\xFC\x52\x6B\x3A\x37\xF8\xF3\x71\x4E\x51\x3B\x1B\xED\x5B"
			"\x08\x21\x5F\x27\x96\xD7\x80\xD0\x6B\x0F\xD8\xB3\x0B\xAB\x48\xB4\x42\xC0\xFA"
			"\x25\x9E\x32\x79\x87\x61\x68\x28\x6F\x18\x77\xD8\x12\xA8\xED\x3D\xE7\xC6\xAE"
			"\xA8\xBE\xDC\xF6\x72\x33\xDD\x01\xAB\xE2\x34\xAB";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/dlies2048.dat", true, new HexDecoder);
		DLIES<SHA1,CompatibleCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		DLIES<SHA1,CompatibleCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

#if 0
		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "2048-bit, CompatCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;
#endif

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	return pass;
}

// Test data generated with Crypto++ 5.6.2.
bool ValidateLegacyECIES()
{
	std::cout << "\nLegacy ECIES validation suite running...\n\n";

	bool pass = true, fail;
	static const char plain[4] = {'a','b','c'};

	{
		// secp160r1, SHA1
		static const size_t size = 64;
		static const byte cipher[size+1] =
			"\x04\xF9\xF8\x82\x8F\xFE\xA3\x47\x92\xE7\xF9\x6B\x19\xE4\x0D\x36\x2B\xA7\x26\xD3"
			"\x43\x17\x99\x3B\xCA\x37\xEB\x3A\x7C\xC4\xCE\x08\x9E\x23\x37\x75\x8B\xCD\x61\xF2"
			"\x44\x88\x0C\x69\x32\xCE\xFA\x0E\x2E\x7B\x09\xA0\xEB\x18\xD8\x0D\x28\xF8\xFF\x4A"
			"\xB2\x06\x7B\xB2";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp160.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp160r1, NoCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// secp256r1, SHA1
		static const size_t size = 88;
		static const byte cipher[size+1] =
			"\x04\x69\x90\x56\xC6\x19\xDF\xCF\xEE\x61\x5C\x25\x00\xAB\x21\x63\xD0\xE4\x99\x7C"
			"\x29\x42\x31\xBF\x93\x4B\x73\x7D\xD0\xD3\x02\xBA\x4D\xA8\xE2\xCF\x4B\x1A\xB2\xBB"
			"\xB5\x49\xE0\x79\x59\x1D\xC9\x07\xCC\x20\x96\x2F\xD6\x21\x9C\x07\x55\x92\xC8\x9C"
			"\x58\x3D\x1C\x9A\x3F\xF2\x8D\x02\x72\x79\xCC\x17\x0A\xEB\xC7\xAB\xF1\x20\xEB\xCD"
			"\x52\xEB\xC2\x0C\xAC\x8F\x17\x00";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp256.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp256r1, NoCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// secp384r1, SHA1
		static const size_t size = 120;
		static const byte cipher[size+1] =
			"\x04\xA5\xF1\xB3\x24\xFE\x82\x62\x47\x10\xA0\xE9\xC9\xA0\x17\x86\xC9\x82\x39\xC1"
			"\x18\x51\x23\x40\x3A\x85\x5E\x89\xDD\x72\xA8\xC4\xF2\x71\xE7\xC4\x61\x1A\xFF\xE8"
			"\xBF\xA2\x7F\xBB\xDF\x60\x96\x04\x54\x05\xD5\x27\x86\xCF\x73\xBF\x43\x2C\x65\x77"
			"\xA4\xE2\xD5\x3B\xC8\x6A\xF6\x87\x8B\x70\x9E\xEF\x1E\x53\x20\x23\x9E\xA5\xA8\xA0"
			"\x72\x9C\x96\x11\x8E\x48\xFB\xBE\x8D\x32\x03\x8D\x9D\x7C\xDA\x2B\x47\xFA\x20\x9E"
			"\x15\x0D\xB8\x7A\x06\x95\xA8\x78\xB8\x40\x21\x24\x45\xC5\x90\x5B\xD7\x8F\xFA\xD7";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp384.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp384r1, NoCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// secp521r1, SHA1
		static const size_t size = 156;
		static const byte cipher[size+1] =
			"\x04\x01\x00\x62\xC1\x03\x83\x8E\x96\x81\x27\xBA\x59\x27\x42\xF1\x9F\x5E\x00\x7F"
			"\xD2\x0F\xE9\x46\xC3\xFE\x23\x14\xD1\xDF\xCF\xE8\x3A\x94\xDD\xEE\xDD\x3D\x25\x0C"
			"\xC7\x70\x38\x44\x9A\x99\x50\x57\xD9\x9C\x50\x62\xC9\x54\x09\x8E\xEB\xFA\xD0\xCE"
			"\xD5\x8A\xCA\x71\x7D\x71\x0E\x00\x61\x25\x6D\xB6\x33\x40\x25\xCA\x44\xD3\xE3\xC0"
			"\xE9\x2F\xD7\x6C\xAF\xB2\x54\x00\x71\xFF\xE5\x0D\xD6\x7E\xF8\x22\x4B\x75\x4B\xE7"
			"\xA8\x6A\x99\x7F\x84\x6D\x7D\xC2\x9F\x2A\x12\x3C\xDF\xAC\xD3\xD0\x66\x41\x8D\x34"
			"\x16\x30\xB4\x2A\xDF\xA2\x0F\x72\x4A\xC6\x8D\xEA\x8D\x27\x38\x7B\x42\xEF\x4E\x01"
			"\x8F\x22\x4A\x50\x4A\x89\x76\xAD\xB2\xB2\xAA\xC2\x5F\x25\xFF\xA3";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp521.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,NoCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp521r1, NoCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

#if 0
	{
		// secp160r1, SHA1
		static const size_t size = 234;
		static const byte cipher[size+1] =
			"\x04\x4C\x5E\xE7\xE5\xBE\xEB\xDF\x9C\xE3\x6A\xC2\x94\xBE\x16\xED\xAA\xA1\xA3"
			"\x6D\x12\xB0\x8A\x25\xDA\xF5\x95\x45\x44\x9C\x5F\xA4\xD6\x2B\x74\xA7\x6A\x91"
			"\x22\x9D\x8D\xF4\x80\x49\x0C\x5F\xE5\x5E\x80\x59\x40\xD7\x8A\x53\xA4\xCF\xF4";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp160.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(64));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp160r1, CompatCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// secp256r1, SHA1
		static const size_t size = 152*4+8*2;
		static const byte cipher[size+1] =
			"\x04\x4C\x5E\xE7\xE5\xBE\xEB\xDF\x9C\xE3\x6A\xC2\x94\xBE\x16\xED\xAA\xA1\xA3"
			"\x6D\x12\xB0\x8A\x25\xDA\xF5\x95\x45\x44\x9C\x5F\xA4\xD6\x2B\x74\xA7\x6A\x91"
			"\x22\x9D\x8D\xF4\x80\x49\x0C\x5F\xE5\x5E\x80\x59\x40\xD7\x8A\x53\xA4\xCF\xF4"
			"\xDD\x19\x39\xEB\xEE\xFA\xDB\x04\xB0\xF5\xC0\xD5\x1D\x89\x4D\xBF\x90\x6E\x6B"
			"\xC4\xC1\x41\x86\x3A\x18\xA7\x78\x2C\x9D\xFA\x49\x84\x00\x63\x84\x97\xE8\x93"
			"\x77\xC8\x53\x6E\xD1\x43\x1A\x04\x9B\x74\x79\xFB\x03\x5C\x86\x8A\x84\x12\x2F"
			"\x6D\x5D\x24\xEF\xF6\x2B\xBF\x08\x1B\x2A\x61\x88\x1D\x4D\x24\xCF\x36\xEE\x43"
			"\x77\x91\x06\x3E\x35\xF0\xCF\x53\x9F\x45\x8F\xC0\x10\xCE\x45\x9D\x02\xED\xB0";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp256.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp256r1, CompatCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// secp384r1, SHA1
		static const size_t size = 272*4+15*2;
		static const byte cipher[size+1] =
			"\x04\x4C\x5E\xE7\xE5\xBE\xEB\xDF\x9C\xE3\x6A\xC2\x94\xBE\x16\xED\xAA\xA1\xA3"
			"\x6D\x12\xB0\x8A\x25\xDA\xF5\x95\x45\x44\x9C\x5F\xA4\xD6\x2B\x74\xA7\x6A\x91"
			"\x22\x9D\x8D\xF4\x80\x49\x0C\x5F\xE5\x5E\x80\x59\x40\xD7\x8A\x53\xA4\xCF\xF4"
			"\xDD\x19\x39\xEB\xEE\xFA\xDB\x04\xB0\xF5\xC0\xD5\x1D\x89\x4D\xBF\x90\x6E\x6B"
			"\xC4\xC1\x41\x86\x3A\x18\xA7\x78\x2C\x9D\xFA\x49\x84\x00\x63\x84\x97\xE8\x93"
			"\x77\xC8\x53\x6E\xD1\x43\x1A\x04\x9B\x74\x79\xFB\x03\x5C\x86\x8A\x84\x12\x2F"
			"\x6D\x5D\x24\xEF\xF6\x2B\xBF\x08\x1B\x2A\x61\x88\x1D\x4D\x24\xCF\x36\xEE\x43"
			"\x77\x91\x06\x3E\x35\xF0\xCF\x53\x9F\x45\x8F\xC0\x10\xCE\x45\x9D\x02\xED\xB0"
			"\x04\x00\x4F\xB5\x5D\xCF\x9B\x62\x54\x43\x5E\xF4\x54\xEB\xC0\xB0\x40\x01\x22"
			"\xF3\xA9\xA4\x97\x87\xFA\x55\xEA\x1B\x4A\x2C\xBE\xC7\x5D\x0B\x27\xA1\xB9\x95"
			"\x4D\x12\x58\xA9\x6E\x6A\x64\xCA\x22\x46\x7C\x61\xFE\x1F\xCF\x63\xF4\x53\x37"
			"\xC7\xF8\x11\x06\xEC\x15\x43\xE8\xEA\x14\x01\xB5\xA3\x0D\xD0\x7A\xE3\x13\x57"
			"\xEE\xC7\x04\x81\xEE\x4F\xC8\x74\x9E\x28\x6A\x4F\xEC\x5C\x24\xA6\x01\xB6\x85"
			"\x5C\xF4\x37\xC5\x8A\x8C\x80\x38\x78\x4A\xEB\x18\x79\xBD\x62\x15\x2A\xA8\x76"
			"\x1E\xD0\xCC\x35\x28\x26\xED\xF9\x6D\xD8\xD8\x5A\xBC\xAC\x8E\x01\x8F\x25\xEF"
			"\xF5\x82\x16\x4D\x97\x10\x54\x40\x68\x72\x2C\x0A\x93\x03\xBE\xD7\x1C\x5F\x07"
			"\xDB\xF8\xBD\x09";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp384.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp384r1, CompatCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}

	{
		// secp521r1, SHA1
		static const size_t size = 428*4+23*2;
		static const byte cipher[size+1] =
			"\x04\x4C\x5E\xE7\xE5\xBE\xEB\xDF\x9C\xE3\x6A\xC2\x94\xBE\x16\xED\xAA\xA1\xA3"
			"\x6D\x12\xB0\x8A\x25\xDA\xF5\x95\x45\x44\x9C\x5F\xA4\xD6\x2B\x74\xA7\x6A\x91"
			"\x22\x9D\x8D\xF4\x80\x49\x0C\x5F\xE5\x5E\x80\x59\x40\xD7\x8A\x53\xA4\xCF\xF4"
			"\xDD\x19\x39\xEB\xEE\xFA\xDB\x04\xB0\xF5\xC0\xD5\x1D\x89\x4D\xBF\x90\x6E\x6B"
			"\xC4\xC1\x41\x86\x3A\x18\xA7\x78\x2C\x9D\xFA\x49\x84\x00\x63\x84\x97\xE8\x93"
			"\x77\xC8\x53\x6E\xD1\x43\x1A\x04\x9B\x74\x79\xFB\x03\x5C\x86\x8A\x84\x12\x2F"
			"\x6D\x5D\x24\xEF\xF6\x2B\xBF\x08\x1B\x2A\x61\x88\x1D\x4D\x24\xCF\x36\xEE\x43"
			"\x77\x91\x06\x3E\x35\xF0\xCF\x53\x9F\x45\x8F\xC0\x10\xCE\x45\x9D\x02\xED\xB0"
			"\x04\x00\x4F\xB5\x5D\xCF\x9B\x62\x54\x43\x5E\xF4\x54\xEB\xC0\xB0\x40\x01\x22"
			"\xF3\xA9\xA4\x97\x87\xFA\x55\xEA\x1B\x4A\x2C\xBE\xC7\x5D\x0B\x27\xA1\xB9\x95"
			"\x4D\x12\x58\xA9\x6E\x6A\x64\xCA\x22\x46\x7C\x61\xFE\x1F\xCF\x63\xF4\x53\x37"
			"\xC7\xF8\x11\x06\xEC\x15\x43\xE8\xEA\x14\x01\xB5\xA3\x0D\xD0\x7A\xE3\x13\x57"
			"\xEE\xC7\x04\x81\xEE\x4F\xC8\x74\x9E\x28\x6A\x4F\xEC\x5C\x24\xA6\x01\xB6\x85"
			"\x5C\xF4\x37\xC5\x8A\x8C\x80\x38\x78\x4A\xEB\x18\x79\xBD\x62\x15\x2A\xA8\x76"
			"\x1E\xD0\xCC\x35\x28\x26\xED\xF9\x6D\xD8\xD8\x5A\xBC\xAC\x8E\x01\x8F\x25\xEF"
			"\xF5\x82\x16\x4D\x97\x10\x54\x40\x68\x72\x2C\x0A\x93\x03\xBE\xD7\x1C\x5F\x07"
			"\xDB\xF8\xBD\x09\x04\x00\x5A\xFC\xC2\xBF\x13\xFE\x2F\xF0\xF8\xCB\x6B\x1A\x68"
			"\xF7\xA2\xB4\xB5\xF0\x39\xA9\x33\xC5\xEC\x8E\xA4\xA5\xFD\x38\xF1\xDF\x6E\x8B"
			"\x11\x11\xDE\x52\xF3\x14\x77\x91\xB7\x3F\x08\x8F\x9E\x32\x76\xBA\x72\x7E\xC6"
			"\x41\x89\x32\x42\x9C\x62\xD4\xE4\x4F\x06\x2E\x71\xE9\x99\x00\xCE\x8D\x7C\xF9"
			"\x3D\xC8\x61\xDA\xCC\xD0\x24\xC4\x6A\xB5\x68\xC5\xD9\xB6\xFF\x02\x35\x79\xAF"
			"\x9C\x50\xE2\x37\x3B\xA8\x80\x72\x06\xB3\xAF\x1B\xC5\x9F\xC1\x0A\x8E\x57\x81"
			"\x40\x95\xEA\x92\x02\xAE\x1C\x91\x1A\xF9\x8A\xCF\x23\x90\xD3\x60\x05\x07\xA6"
			"\x8C\x58\xC6\xE6\x62\x08\x5A\x49\x26\xA6\xFA\x4C\x45\x2B\x30\x4F\x6F\x17\x55"
			"\xBA\xAF\x64\xF3\x59\x75\x29\xB5";

		FileSource keys(CRYPTOPP_DATA_DIR "TestData/ecies_secp521.dat", true, new HexDecoder);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Decryptor decryptor(keys);
		ECIES<ECP,SHA1,CompatibleCofactorMultiplication,true,true>::Encryptor encryptor(decryptor);

		SecByteBlock recovered(decryptor.MaxPlaintextLength(size));
		fail = decryptor.Decrypt(GlobalRNG(), cipher, size, recovered) != DecodingResult(3);
		fail = fail || memcmp(plain, recovered, 3);

		std::cout << (fail ? "FAILED    " : "passed    ") << "secp521r1, CompatCofactorMult,DHAES_MODE=true,LABEL_OCTET=true\n";
		pass = pass && !fail;

		// Pairwise testing
		pass = CryptoSystemValidate(decryptor, encryptor) && pass;
	}
#endif

	return pass;
}

bool ValidateInteropDLIES()
{
	std::cout << "\nInteroperable DLIES validation suite running...\n\n";

	return true;
}

bool ValidateInteropECIES()
{
	std::cout << "\nInteroperable ECIES validation suite running...\n\n";

	return true;
}
